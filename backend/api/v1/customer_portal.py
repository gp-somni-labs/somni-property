"""
Customer Portal API - Public Endpoints for Customer Access
No authentication required - uses JWT token verification instead

Integrates with:
- InvoiceNinja for invoice management and payment recording
- Stripe for payment processing
- Email service for notifications
"""

from fastapi import APIRouter, HTTPException, Depends, Header, BackgroundTasks
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, update
from sqlalchemy.orm import selectinload
from pydantic import BaseModel, Field
from typing import Optional, Dict, Any, List
from uuid import UUID
import jwt
import logging
from datetime import datetime, date
from decimal import Decimal

from db.database import get_db
from core.config import settings
from core.exceptions import (
    InvoiceNinjaError,
    StripeError,
    ResourceNotFoundError,
    ValidationError,
    ExternalServiceError
)
from services.client_onboarding_service import get_client_onboarding_service
from services.invoiceninja_client import (
    get_invoiceninja_client,
    InvoiceNinjaClient as INClient,
    InvoiceLineItem,
    InvoiceStatus,
    PaymentType
)
from db.models_quotes import Quote as QuoteModel
from api.schemas_quotes import Quote

router = APIRouter()
logger = logging.getLogger(__name__)


# ============================================================================
# INVOICE NINJA CLIENT INITIALIZATION
# ============================================================================

def get_invoice_ninja() -> INClient:
    """Get configured Invoice Ninja client"""
    return get_invoiceninja_client(
        base_url=settings.INVOICE_NINJA_URL,
        api_token=settings.INVOICE_NINJA_TOKEN
    )


# ============================================================================
# REQUEST/RESPONSE MODELS
# ============================================================================

class TokenVerifyRequest(BaseModel):
    """Request to verify a customer portal token"""
    token: str


class TokenVerifyResponse(BaseModel):
    """Verified token payload"""
    client_id: str
    portal_type: str  # 'payment', 'quote', 'progress'
    resource_id: Optional[str] = None
    exp: int
    iat: int


# ============================================================================
# TOKEN VERIFICATION ENDPOINT
# ============================================================================

@router.post("/customer-portal/verify-token", response_model=TokenVerifyResponse)
async def verify_customer_portal_token(
    request: TokenVerifyRequest,
    db: AsyncSession = Depends(get_db)
):
    """
    Verify a JWT token from a customer portal secure link

    This endpoint is public (no auth required) and validates JWT tokens
    generated by the customer notification service.

    Returns the decoded payload if valid, raises 401 if expired/invalid.
    """
    jwt_secret = getattr(settings, 'JWT_SECRET_KEY', 'your-secret-key-change-in-production')

    try:
        # Decode and verify JWT token
        payload = jwt.decode(
            request.token,
            jwt_secret,
            algorithms=['HS256']
        )

        # Validate required fields
        if 'client_id' not in payload or 'portal_type' not in payload:
            raise HTTPException(
                status_code=400,
                detail="Invalid token payload: missing required fields"
            )

        # Validate portal_type
        valid_portal_types = ['payment', 'quote', 'progress']
        if payload['portal_type'] not in valid_portal_types:
            raise HTTPException(
                status_code=400,
                detail=f"Invalid portal_type: must be one of {valid_portal_types}"
            )

        logger.info(
            f"Token verified successfully: client_id={payload['client_id']}, "
            f"portal_type={payload['portal_type']}, resource_id={payload.get('resource_id')}"
        )

        return TokenVerifyResponse(
            client_id=payload['client_id'],
            portal_type=payload['portal_type'],
            resource_id=payload.get('resource_id'),
            exp=int(payload['exp']),
            iat=int(payload['iat'])
        )

    except jwt.ExpiredSignatureError:
        logger.warning(f"Expired token verification attempt")
        raise HTTPException(
            status_code=401,
            detail="Token has expired. Please contact support for a new link."
        )

    except jwt.InvalidTokenError as e:
        logger.warning(f"Invalid token verification attempt: {e}")
        raise HTTPException(
            status_code=401,
            detail="Invalid token. Please verify your link is correct."
        )

    except Exception as e:
        logger.error(f"Unexpected error during token verification: {e}")
        raise HTTPException(
            status_code=500,
            detail="An error occurred while verifying your access."
        )


# ============================================================================
# HELPER: TOKEN VALIDATION
# ============================================================================

async def validate_token_and_get_payload(token: str, expected_portal_type: Optional[str] = None) -> Dict:
    """
    Validate JWT token and return payload
    Optionally validate portal_type matches expected type
    """
    jwt_secret = getattr(settings, 'JWT_SECRET_KEY', 'your-secret-key-change-in-production')

    try:
        payload = jwt.decode(token, jwt_secret, algorithms=['HS256'])

        # Validate portal_type if specified
        if expected_portal_type and payload.get('portal_type') != expected_portal_type:
            raise HTTPException(
                status_code=403,
                detail=f"This link is not valid for {expected_portal_type} access"
            )

        return payload

    except jwt.ExpiredSignatureError:
        raise HTTPException(
            status_code=401,
            detail="Token has expired. Please contact support for a new link."
        )
    except jwt.InvalidTokenError:
        raise HTTPException(
            status_code=401,
            detail="Invalid token. Please verify your link is correct."
        )


# ============================================================================
# CUSTOMER PORTAL RESOURCE ENDPOINTS
# ============================================================================

class OnboardingProgressResponse(BaseModel):
    """Customer onboarding progress information"""
    client_id: str
    client_name: str
    current_stage: str
    current_step: int
    progress_percent: int
    onboarding_completed: bool
    onboarded_at: Optional[str]
    current_stage_validation: Dict[str, Any]
    next_stage: Optional[str]
    next_stage_requirements: List[str]
    discovery_call_scheduled_at: Optional[str]
    discovery_call_completed_at: Optional[str]
    initial_assessment_completed: bool
    stages: List[str]
    stage_progress_map: Dict[str, int]


@router.get("/customer-portal/progress/{client_id}", response_model=OnboardingProgressResponse)
async def get_customer_onboarding_progress(
    client_id: UUID,
    token: str = Header(..., alias="X-Customer-Token"),
    db: AsyncSession = Depends(get_db)
):
    """
    Get onboarding progress for customer (Public endpoint)

    Validates JWT token and ensures it matches the client_id being requested.
    Customer can only view their own onboarding progress.
    """
    # Validate token
    payload = await validate_token_and_get_payload(token, expected_portal_type='progress')

    # Ensure client_id in token matches requested client_id
    if payload['client_id'] != str(client_id):
        raise HTTPException(
            status_code=403,
            detail="You do not have permission to view this client's information"
        )

    # Get onboarding progress
    onboarding_service = get_client_onboarding_service(db)
    progress = await onboarding_service.get_onboarding_progress(client_id)

    logger.info(f"Customer portal: Client {client_id} viewed onboarding progress")

    return OnboardingProgressResponse(**progress)


@router.get("/customer-portal/quotes/{quote_id}", response_model=Quote)
async def get_customer_quote(
    quote_id: UUID,
    token: str = Header(..., alias="X-Customer-Token"),
    db: AsyncSession = Depends(get_db)
):
    """
    Get quote details for customer (Public endpoint)

    Validates JWT token and ensures it matches the quote being requested.
    Customer can only view quotes linked to their secure token.
    """
    # Validate token
    payload = await validate_token_and_get_payload(token, expected_portal_type='quote')

    # Ensure resource_id in token matches requested quote_id
    if payload.get('resource_id') != str(quote_id):
        raise HTTPException(
            status_code=403,
            detail="You do not have permission to view this quote"
        )

    # Get quote with eagerly loaded line items
    query = select(QuoteModel).options(selectinload(QuoteModel.line_items)).where(QuoteModel.id == quote_id)
    result = await db.execute(query)
    quote = result.scalar_one_or_none()

    if not quote:
        raise HTTPException(status_code=404, detail="Quote not found")

    logger.info(f"Customer portal: Quote {quote_id} viewed by customer {quote.customer_email}")

    return quote


class InvoiceLineItemResponse(BaseModel):
    """Invoice line item for customer view"""
    description: str
    quantity: float
    unit_price: float
    total: float


class InvoiceResponse(BaseModel):
    """Invoice information for customer portal"""
    id: str
    number: str
    amount: float
    balance: float  # Remaining amount to pay
    due_date: Optional[str]
    invoice_date: Optional[str]
    status: str
    status_label: str
    customer_email: str
    customer_name: Optional[str]
    description: Optional[str]
    line_items: List[InvoiceLineItemResponse] = []
    public_notes: Optional[str] = None
    terms: Optional[str] = None
    is_paid: bool = False
    payment_url: Optional[str] = None


def _get_invoice_status_label(status_id: int) -> str:
    """Convert Invoice Ninja status ID to human-readable label"""
    status_map = {
        1: "Draft",
        2: "Sent",
        3: "Viewed",
        4: "Approved",
        5: "Partial",
        6: "Paid",
        -1: "Overdue",
        -2: "Unpaid"
    }
    return status_map.get(status_id, "Unknown")


@router.get("/customer-portal/invoices/{invoice_id}", response_model=InvoiceResponse)
async def get_customer_invoice(
    invoice_id: str,
    token: str = Header(..., alias="X-Customer-Token"),
    db: AsyncSession = Depends(get_db)
):
    """
    Get invoice details for customer (Public endpoint)

    Validates JWT token and ensures it matches the invoice being requested.
    Customer can only view invoices linked to their secure token.
    Fetches real invoice data from Invoice Ninja.
    """
    # Validate token
    payload = await validate_token_and_get_payload(token, expected_portal_type='payment')

    # Ensure resource_id in token matches requested invoice_id
    if payload.get('resource_id') != invoice_id:
        raise HTTPException(
            status_code=403,
            detail="You do not have permission to view this invoice"
        )

    # Fetch invoice from Invoice Ninja
    try:
        ninja_client = get_invoice_ninja()
        invoice = await ninja_client.get_invoice(invoice_id)

        if not invoice:
            logger.warning(f"Invoice {invoice_id} not found in Invoice Ninja")
            raise ResourceNotFoundError(
                resource_type="invoice",
                resource_id=invoice_id
            )

        # Get client details for email/name
        client = await ninja_client.get_client(invoice.client_id) if invoice.client_id else None

        # Parse line items from invoice data
        line_items = []
        if invoice.line_items:
            for item in invoice.line_items:
                line_items.append(InvoiceLineItemResponse(
                    description=item.notes,
                    quantity=item.quantity,
                    unit_price=item.cost,
                    total=item.cost * item.quantity
                ))

        status_id = invoice.status_id or 1
        is_paid = status_id == 6

        logger.info(f"Customer portal: Invoice {invoice_id} viewed by customer")

        return InvoiceResponse(
            id=invoice_id,
            number=invoice.invoice_number or f"INV-{invoice_id[:8].upper()}",
            amount=invoice.amount or 0.0,
            balance=invoice.balance or 0.0,
            due_date=invoice.due_date.isoformat() if invoice.due_date else None,
            invoice_date=invoice.invoice_date.isoformat() if invoice.invoice_date else None,
            status=str(status_id),
            status_label=_get_invoice_status_label(status_id),
            customer_email=client.email if client else payload.get('client_id', ''),
            customer_name=client.name if client else None,
            description=invoice.public_notes,
            line_items=line_items,
            public_notes=invoice.public_notes,
            terms=invoice.terms,
            is_paid=is_paid,
            payment_url=f"{settings.CUSTOMER_PORTAL_BASE_URL}/pay/{invoice_id}" if not is_paid else None
        )

    except ResourceNotFoundError:
        raise
    except Exception as e:
        logger.error(f"Error fetching invoice from Invoice Ninja: {e}")
        raise InvoiceNinjaError(
            message="Unable to retrieve invoice details",
            details={"invoice_id": invoice_id, "error": str(e)}
        )


class PaymentRequest(BaseModel):
    """Payment processing request"""
    invoice_id: str
    payment_method: str = Field(..., pattern="^(card|bank_transfer|ach)$")
    card_details: Optional[Dict[str, Any]] = None
    partial_amount: Optional[float] = None  # For partial payments


class PaymentResponse(BaseModel):
    """Payment processing response"""
    success: bool
    transaction_id: Optional[str]
    message: str
    payment_amount: Optional[float] = None
    remaining_balance: Optional[float] = None
    payment_recorded_in_ninja: bool = False


class BankTransferInstructions(BaseModel):
    """Bank transfer instructions for customer"""
    bank_name: str
    account_name: str
    account_number: str
    routing_number: str
    reference: str
    amount: float
    due_date: Optional[str]
    instructions: str


@router.get("/customer-portal/invoices/{invoice_id}/bank-transfer", response_model=BankTransferInstructions)
async def get_bank_transfer_instructions(
    invoice_id: str,
    token: str = Header(..., alias="X-Customer-Token"),
    db: AsyncSession = Depends(get_db)
):
    """
    Get bank transfer instructions for an invoice (Public endpoint)

    Returns ACH/wire transfer details for paying an invoice via bank transfer.
    """
    # Validate token
    payload = await validate_token_and_get_payload(token, expected_portal_type='payment')

    if payload.get('resource_id') != invoice_id:
        raise HTTPException(
            status_code=403,
            detail="You do not have permission to view this invoice"
        )

    # Get invoice from Invoice Ninja
    try:
        ninja_client = get_invoice_ninja()
        invoice = await ninja_client.get_invoice(invoice_id)

        if not invoice:
            raise ResourceNotFoundError(resource_type="invoice", resource_id=invoice_id)

        # Generate reference number from invoice
        reference = f"INV-{invoice.invoice_number or invoice_id[:8].upper()}"

        return BankTransferInstructions(
            bank_name="Chase Bank",  # Configure via settings in production
            account_name="Somni Property Management LLC",
            account_number="****1234",  # Masked - full details sent via secure email
            routing_number="****5678",  # Masked
            reference=reference,
            amount=invoice.balance or invoice.amount or 0.0,
            due_date=invoice.due_date.isoformat() if invoice.due_date else None,
            instructions=(
                f"Please include reference '{reference}' in the memo/description field. "
                f"Payment typically clears within 2-3 business days. "
                f"Full account details have been sent to your email for security. "
                f"Contact us if you have any questions about making this payment."
            )
        )

    except ResourceNotFoundError:
        raise
    except Exception as e:
        logger.error(f"Error getting bank transfer instructions: {e}")
        raise InvoiceNinjaError(
            message="Unable to retrieve payment instructions",
            details={"invoice_id": invoice_id}
        )


async def _send_payment_confirmation_email(
    customer_email: str,
    customer_name: str,
    invoice_number: str,
    amount: float,
    transaction_id: str,
    payment_method: str
):
    """Send payment confirmation email to customer"""
    try:
        from services.email_service import send_email

        subject = f"Payment Confirmation - Invoice {invoice_number}"
        body = f"""
Dear {customer_name or 'Valued Customer'},

Thank you for your payment!

Payment Details:
- Invoice: {invoice_number}
- Amount: ${amount:.2f}
- Payment Method: {payment_method.replace('_', ' ').title()}
- Transaction ID: {transaction_id}
- Date: {datetime.now().strftime('%B %d, %Y at %I:%M %p')}

Your payment has been recorded and your invoice has been updated.

If you have any questions about this payment, please contact us.

Best regards,
Somni Property Management
        """

        await send_email(
            to_email=customer_email,
            subject=subject,
            body=body,
            from_email=settings.NOTIFICATIONS_FROM_EMAIL,
            from_name=settings.NOTIFICATIONS_FROM_NAME
        )
        logger.info(f"Payment confirmation email sent to {customer_email}")

    except Exception as e:
        # Don't fail the payment if email fails
        logger.error(f"Failed to send payment confirmation email: {e}")


async def _record_payment_in_invoiceninja(
    ninja_client: INClient,
    invoice_id: str,
    amount: float,
    payment_method: str,
    transaction_id: str
) -> bool:
    """Record payment in Invoice Ninja"""
    try:
        # Map payment method to Invoice Ninja type
        payment_type_map = {
            'card': PaymentType.STRIPE.value,
            'bank_transfer': PaymentType.BANK_TRANSFER.value,
            'ach': PaymentType.BANK_TRANSFER.value
        }
        payment_type_id = payment_type_map.get(payment_method, PaymentType.BANK_TRANSFER.value)

        payment = await ninja_client.record_payment(
            invoice_id=invoice_id,
            amount=amount,
            payment_date=date.today(),
            payment_type_id=payment_type_id,
            transaction_reference=transaction_id,
            private_notes=f"Recorded via customer portal ({payment_method})"
        )

        if payment:
            logger.info(f"Payment recorded in Invoice Ninja: {payment.id} for invoice {invoice_id}")
            return True
        else:
            logger.warning(f"Failed to record payment in Invoice Ninja for invoice {invoice_id}")
            return False

    except Exception as e:
        logger.error(f"Error recording payment in Invoice Ninja: {e}")
        return False


@router.post("/customer-portal/payments/process", response_model=PaymentResponse)
async def process_customer_payment(
    payment_data: PaymentRequest,
    background_tasks: BackgroundTasks,
    token: str = Header(..., alias="X-Customer-Token"),
    db: AsyncSession = Depends(get_db)
):
    """
    Process payment for invoice (Public endpoint)

    Validates JWT token and processes payment via Stripe or bank transfer.
    Records payment in Invoice Ninja and sends confirmation email.
    """
    from services.stripe_service import StripeService

    # Validate token
    payload = await validate_token_and_get_payload(token, expected_portal_type='payment')

    # Ensure resource_id in token matches invoice being paid
    if payload.get('resource_id') != payment_data.invoice_id:
        raise HTTPException(
            status_code=403,
            detail="You do not have permission to pay this invoice"
        )

    # Get invoice from Invoice Ninja
    ninja_client = get_invoice_ninja()
    invoice = await ninja_client.get_invoice(payment_data.invoice_id)

    if not invoice:
        raise ResourceNotFoundError(
            resource_type="invoice",
            resource_id=payment_data.invoice_id
        )

    # Check if already paid
    if invoice.status_id == 6:  # Paid
        return PaymentResponse(
            success=False,
            transaction_id=None,
            message="This invoice has already been paid.",
            payment_amount=0,
            remaining_balance=0,
            payment_recorded_in_ninja=False
        )

    # Determine payment amount (use partial if specified, otherwise full balance)
    payment_amount = payment_data.partial_amount or invoice.balance or invoice.amount or 0.0

    if payment_amount <= 0:
        raise ValidationError(
            message="Invalid payment amount",
            details={"amount": payment_amount}
        )

    # Get client details
    client = await ninja_client.get_client(invoice.client_id) if invoice.client_id else None
    customer_email = client.email if client else payload.get('client_id', '')
    customer_name = client.name if client else "Customer"

    # Handle bank transfer - just record intent, actual payment recorded when received
    if payment_data.payment_method in ('bank_transfer', 'ach'):
        logger.info(f"Bank transfer initiated for invoice: {payment_data.invoice_id}")

        # Send bank transfer instructions via email
        background_tasks.add_task(
            _send_bank_transfer_email,
            customer_email,
            customer_name,
            invoice.invoice_number or payment_data.invoice_id,
            payment_amount
        )

        return PaymentResponse(
            success=True,
            transaction_id=None,
            message=(
                "Bank transfer instructions have been sent to your email. "
                "Your payment will be confirmed once the transfer is received (typically 2-3 business days)."
            ),
            payment_amount=payment_amount,
            remaining_balance=invoice.balance,
            payment_recorded_in_ninja=False
        )

    # Handle card payment via Stripe
    if payment_data.payment_method == 'card':
        stripe_service = StripeService()

        # Check if Stripe is configured
        if not settings.STRIPE_SECRET_KEY:
            logger.error("Stripe payment requested but API key not configured")
            raise ExternalServiceError(
                service_name="Stripe",
                message="Payment processing is currently unavailable"
            )

        try:
            # Create or get Stripe customer
            customer = await stripe_service.create_customer(
                email=customer_email,
                name=customer_name,
                metadata={
                    'invoice_id': payment_data.invoice_id,
                    'invoiceninja_client_id': invoice.client_id
                }
            )

            # Create payment intent
            payment_intent = await stripe_service.create_payment_intent(
                amount=Decimal(str(payment_amount)),
                customer_id=customer['id'],
                description=f"Invoice payment: {invoice.invoice_number or payment_data.invoice_id}",
                metadata={
                    'invoice_id': payment_data.invoice_id,
                    'invoice_number': invoice.invoice_number,
                    'client_id': payload.get('client_id'),
                    'invoiceninja_client_id': invoice.client_id
                }
            )

            transaction_id = payment_intent['id']

            logger.info(
                f"Customer portal: Payment intent created {transaction_id} "
                f"for invoice {payment_data.invoice_id}, amount ${payment_amount:.2f}"
            )

            # Record payment in Invoice Ninja
            payment_recorded = await _record_payment_in_invoiceninja(
                ninja_client=ninja_client,
                invoice_id=payment_data.invoice_id,
                amount=payment_amount,
                payment_method=payment_data.payment_method,
                transaction_id=transaction_id
            )

            # Calculate remaining balance
            remaining_balance = max(0, (invoice.balance or invoice.amount or 0) - payment_amount)

            # Send payment confirmation email in background
            background_tasks.add_task(
                _send_payment_confirmation_email,
                customer_email,
                customer_name,
                invoice.invoice_number or payment_data.invoice_id,
                payment_amount,
                transaction_id,
                payment_data.payment_method
            )

            return PaymentResponse(
                success=True,
                transaction_id=transaction_id,
                message="Payment processed successfully! A confirmation email has been sent.",
                payment_amount=payment_amount,
                remaining_balance=remaining_balance,
                payment_recorded_in_ninja=payment_recorded
            )

        except Exception as e:
            logger.error(f"Payment processing failed: {e}")
            raise StripeError(
                message="Payment processing failed",
                details={"error": str(e)}
            )

    # Unknown payment method
    raise ValidationError(
        message=f"Unknown payment method: {payment_data.payment_method}",
        details={"supported_methods": ["card", "bank_transfer", "ach"]}
    )


async def _send_bank_transfer_email(
    customer_email: str,
    customer_name: str,
    invoice_number: str,
    amount: float
):
    """Send bank transfer instructions email"""
    try:
        from services.email_service import send_email

        reference = f"INV-{invoice_number}"
        subject = f"Bank Transfer Instructions - Invoice {invoice_number}"
        body = f"""
Dear {customer_name or 'Valued Customer'},

Thank you for choosing to pay via bank transfer. Please use the following details:

Bank: Chase Bank
Account Name: Somni Property Management LLC
Account Number: 123456789
Routing Number: 021000021

Amount Due: ${amount:.2f}
Reference: {reference}

IMPORTANT: Please include the reference "{reference}" in the memo/description field
so we can identify your payment.

Payment is typically received within 2-3 business days. You will receive a confirmation
email once your payment has been processed.

If you have any questions, please don't hesitate to contact us.

Best regards,
Somni Property Management
        """

        await send_email(
            to_email=customer_email,
            subject=subject,
            body=body,
            from_email=settings.NOTIFICATIONS_FROM_EMAIL,
            from_name=settings.NOTIFICATIONS_FROM_NAME
        )
        logger.info(f"Bank transfer instructions sent to {customer_email}")

    except Exception as e:
        logger.error(f"Failed to send bank transfer instructions: {e}")


# ============================================================================
# QUOTE ACCEPTANCE & INVOICE CREATION
# ============================================================================

class QuoteAcceptanceRequest(BaseModel):
    """Request to accept a quote"""
    customer_signature: Optional[str] = None  # Base64 encoded signature image
    accept_terms: bool = True
    notes: Optional[str] = None


class QuoteAcceptanceResponse(BaseModel):
    """Response after accepting a quote"""
    success: bool
    message: str
    invoice_id: Optional[str] = None
    invoice_number: Optional[str] = None
    payment_url: Optional[str] = None


@router.post("/customer-portal/quotes/{quote_id}/accept", response_model=QuoteAcceptanceResponse)
async def accept_quote(
    quote_id: UUID,
    acceptance: QuoteAcceptanceRequest,
    background_tasks: BackgroundTasks,
    token: str = Header(..., alias="X-Customer-Token"),
    db: AsyncSession = Depends(get_db)
):
    """
    Accept a quote and create an invoice in Invoice Ninja (Public endpoint)

    When a customer accepts a quote:
    1. Updates quote status to 'accepted'
    2. Creates or finds matching client in Invoice Ninja
    3. Creates invoice from quote line items
    4. Sends invoice notification email
    5. Returns payment URL for immediate payment
    """
    # Validate token
    payload = await validate_token_and_get_payload(token, expected_portal_type='quote')

    if payload.get('resource_id') != str(quote_id):
        raise HTTPException(
            status_code=403,
            detail="You do not have permission to accept this quote"
        )

    if not acceptance.accept_terms:
        raise ValidationError(
            message="You must accept the terms to proceed",
            details={"accept_terms": False}
        )

    # Get quote from database
    query = select(QuoteModel).options(selectinload(QuoteModel.line_items)).where(QuoteModel.id == quote_id)
    result = await db.execute(query)
    quote = result.scalar_one_or_none()

    if not quote:
        raise ResourceNotFoundError(resource_type="quote", resource_id=str(quote_id))

    # Check if quote is already accepted
    if quote.status == 'accepted':
        # If already has invoice, return it
        if quote.invoice_ninja_invoice_id:
            return QuoteAcceptanceResponse(
                success=True,
                message="This quote has already been accepted. Your invoice is ready.",
                invoice_id=quote.invoice_ninja_invoice_id,
                invoice_number=quote.invoice_ninja_invoice_number,
                payment_url=f"{settings.CUSTOMER_PORTAL_BASE_URL}/pay/{quote.invoice_ninja_invoice_id}"
            )
        # Otherwise continue to create invoice

    # Check if quote has expired
    if quote.valid_until and quote.valid_until < datetime.now():
        raise ValidationError(
            message="This quote has expired",
            details={"valid_until": quote.valid_until.isoformat()}
        )

    try:
        ninja_client = get_invoice_ninja()

        # Create or find Invoice Ninja client
        ninja_client_id = quote.invoice_ninja_client_id

        if not ninja_client_id:
            # Create new client in Invoice Ninja
            customer_name = quote.customer_name or quote.customer_email
            new_client = await ninja_client.create_client(
                name=customer_name,
                email=quote.customer_email,
                phone=quote.customer_phone,
                address1=quote.service_address,
                id_number=str(quote.id),  # Use quote ID as reference
                custom_value1=str(quote_id)  # Store quote ID for reference
            )

            if new_client:
                ninja_client_id = new_client.id
                logger.info(f"Created Invoice Ninja client {ninja_client_id} for quote {quote_id}")
            else:
                raise InvoiceNinjaError(
                    message="Failed to create client in Invoice Ninja",
                    details={"quote_id": str(quote_id)}
                )

        # Convert quote line items to invoice line items
        invoice_line_items = []
        for item in quote.line_items:
            invoice_line_items.append(InvoiceLineItem(
                product_key=item.category or "service",
                notes=item.description,
                cost=float(item.unit_price),
                quantity=float(item.quantity)
            ))

        # Create invoice in Invoice Ninja
        due_date = date.today()
        if quote.valid_until:
            # Due date is the quote expiry or 30 days from now, whichever is later
            due_date = max(quote.valid_until.date(), date.today())
        else:
            # Default to 30 days from now
            from datetime import timedelta
            due_date = date.today() + timedelta(days=30)

        invoice = await ninja_client.create_invoice(
            client_id=ninja_client_id,
            line_items=invoice_line_items,
            due_date=due_date,
            po_number=str(quote_id),  # Reference the quote
            public_notes=f"Invoice for Quote #{quote.quote_number or str(quote_id)[:8]}",
            private_notes=f"Auto-generated from quote acceptance. Quote ID: {quote_id}",
            terms=quote.terms_conditions
        )

        if not invoice:
            raise InvoiceNinjaError(
                message="Failed to create invoice in Invoice Ninja",
                details={"quote_id": str(quote_id)}
            )

        # Update quote in database
        quote.status = 'accepted'
        quote.accepted_at = datetime.now()
        quote.invoice_ninja_client_id = ninja_client_id
        quote.invoice_ninja_invoice_id = invoice.id
        quote.invoice_ninja_invoice_number = invoice.invoice_number

        # Store signature if provided
        if acceptance.customer_signature:
            quote.customer_signature = acceptance.customer_signature

        if acceptance.notes:
            quote.acceptance_notes = acceptance.notes

        await db.commit()

        logger.info(
            f"Quote {quote_id} accepted, Invoice {invoice.id} created in Invoice Ninja"
        )

        # Send invoice email via Invoice Ninja in background
        background_tasks.add_task(
            _send_invoice_via_ninja,
            ninja_client,
            invoice.id
        )

        # Calculate total amount (use total_amount if set, otherwise calculate)
        total_amount = quote.total_amount
        if not total_amount:
            # Calculate from line items
            total_amount = sum(
                float(item.subtotal or (item.unit_price * item.quantity))
                for item in quote.line_items
            ) if quote.line_items else 0
            # Add other costs if available
            if quote.setup_fees:
                total_amount += float(quote.setup_fees)
            if quote.hardware_costs:
                total_amount += float(quote.hardware_costs)
            if quote.total_labor_cost:
                total_amount += float(quote.total_labor_cost)

        # Also send our own confirmation email
        background_tasks.add_task(
            _send_quote_acceptance_email,
            quote.customer_email,
            quote.customer_name,
            quote.quote_number or str(quote_id)[:8],
            invoice.invoice_number,
            float(total_amount) if total_amount else 0.0
        )

        return QuoteAcceptanceResponse(
            success=True,
            message="Quote accepted! Your invoice has been created and sent to your email.",
            invoice_id=invoice.id,
            invoice_number=invoice.invoice_number,
            payment_url=f"{settings.CUSTOMER_PORTAL_BASE_URL}/pay/{invoice.id}"
        )

    except (ResourceNotFoundError, ValidationError, InvoiceNinjaError):
        raise
    except Exception as e:
        logger.error(f"Error accepting quote {quote_id}: {e}")
        raise InvoiceNinjaError(
            message="An error occurred while processing your quote acceptance",
            details={"quote_id": str(quote_id), "error": str(e)}
        )


async def _send_invoice_via_ninja(ninja_client: INClient, invoice_id: str):
    """Send invoice email via Invoice Ninja"""
    try:
        success = await ninja_client.send_invoice(invoice_id)
        if success:
            logger.info(f"Invoice {invoice_id} sent via Invoice Ninja")
        else:
            logger.warning(f"Failed to send invoice {invoice_id} via Invoice Ninja")
    except Exception as e:
        logger.error(f"Error sending invoice via Invoice Ninja: {e}")


async def _send_quote_acceptance_email(
    customer_email: str,
    customer_name: str,
    quote_number: str,
    invoice_number: str,
    total_amount: float
):
    """Send quote acceptance confirmation email"""
    try:
        from services.email_service import send_email

        subject = f"Quote Accepted - Invoice {invoice_number} Created"
        body = f"""
Dear {customer_name or 'Valued Customer'},

Thank you for accepting our quote!

Quote Details:
- Quote Number: {quote_number}
- Total Amount: ${total_amount:.2f}

Your invoice (#{invoice_number}) has been created and sent separately to your email.
You can pay online at any time using the secure payment link in your invoice.

Payment Options:
- Credit/Debit Card (processed securely via Stripe)
- Bank Transfer/ACH

If you have any questions about your invoice or need to discuss payment arrangements,
please don't hesitate to contact us.

We appreciate your business and look forward to serving you!

Best regards,
Somni Property Management
        """

        await send_email(
            to_email=customer_email,
            subject=subject,
            body=body,
            from_email=settings.NOTIFICATIONS_FROM_EMAIL,
            from_name=settings.NOTIFICATIONS_FROM_NAME
        )
        logger.info(f"Quote acceptance email sent to {customer_email}")

    except Exception as e:
        logger.error(f"Failed to send quote acceptance email: {e}")


@router.get("/customer-portal/invoices/{invoice_id}/pdf")
async def download_invoice_pdf(
    invoice_id: str,
    token: str = Header(..., alias="X-Customer-Token"),
    db: AsyncSession = Depends(get_db)
):
    """
    Download invoice as PDF from Invoice Ninja (Public endpoint)
    """
    from fastapi.responses import Response

    # Validate token
    payload = await validate_token_and_get_payload(token, expected_portal_type='payment')

    if payload.get('resource_id') != invoice_id:
        raise HTTPException(
            status_code=403,
            detail="You do not have permission to download this invoice"
        )

    try:
        ninja_client = get_invoice_ninja()
        pdf_bytes = await ninja_client.download_invoice_pdf(invoice_id)

        if not pdf_bytes:
            raise ResourceNotFoundError(
                resource_type="invoice PDF",
                resource_id=invoice_id
            )

        return Response(
            content=pdf_bytes,
            media_type="application/pdf",
            headers={
                "Content-Disposition": f"attachment; filename=invoice-{invoice_id}.pdf"
            }
        )

    except ResourceNotFoundError:
        raise
    except Exception as e:
        logger.error(f"Error downloading invoice PDF: {e}")
        raise InvoiceNinjaError(
            message="Unable to download invoice PDF",
            details={"invoice_id": invoice_id}
        )


# ============================================================================
# HEALTH CHECK
# ============================================================================

@router.get("/customer-portal/health")
async def customer_portal_health():
    """Health check for customer portal endpoints"""
    health_status = {
        "status": "healthy",
        "invoice_ninja": "unknown",
        "stripe": "unknown"
    }

    # Check Invoice Ninja connection
    try:
        if settings.INVOICE_NINJA_TOKEN:
            ninja_client = get_invoice_ninja()
            # Try to list clients (limit 1) as health check
            result = await ninja_client.list_clients(page=1, per_page=1)
            health_status["invoice_ninja"] = "connected" if result else "error"
        else:
            health_status["invoice_ninja"] = "not_configured"
    except Exception as e:
        health_status["invoice_ninja"] = f"error: {str(e)}"

    # Check Stripe configuration
    if settings.STRIPE_SECRET_KEY:
        health_status["stripe"] = "configured"
    else:
        health_status["stripe"] = "not_configured"

    return health_status
